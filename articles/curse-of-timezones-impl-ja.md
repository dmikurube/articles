---
title: "タイムゾーン呪いの書 (実装編)"
emoji: "🌏" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "timezone", "tzdb" ]
layout: default
published: false
---

実装にあたって
===============

さて、時刻とタイムゾーンというこの厄介な概念について話を続けるときりがないのですが、一般的な概念については、ここまでである程度は概観できたと思います。では、これを実装に落とし込むとき、具体的にはなににどう気をつけたらいいでしょうか?

ここまで Java の [JSR 310: Date and Time API](https://jcp.org/en/jsr/detail?id=310) を何回か参照してきましたが、この JSR 310 については「単なる日付・時刻を扱うだけなのに複雑すぎる!」という声をよく耳にします。が、ここまで書いてきたように、日付・時刻・タイムゾーンというモノがそもそも超複雑な概念なんだ、という認識がまず必要です。 JSR 310 はこの「超複雑な日付・時刻・タイムゾーンというモノ」をできるだけ忠実にモデル化していて、実装について検討するのにいいモデルケースになると思います。

時刻やタイムゾーンをあつかうときに、「どんな場合でもこうしてさえおけば大丈夫」と言えるような万能の正解はありません。その都度、要件を吟味し、適切なやり方を考えて選ぶ必要があります。以下では JSR 310 を参考にしつつも、言語固有の話にはあまり踏み入らずに、やり方を選ぶための基準や一般的な考え方を以下の三つの観点で紹介していきます。

* 内部データ表現
* データの出力と永続化
* データの入力

言語やソフトウェア固有の話
---------------------------

[Qiita に載せていた旧 2018年版の記事](https://qiita.com/dmikurube/items/15899ec9de643e91497c)では、ここから Java 固有の話を紹介していました。しかし改訂にともなって全体がさらに長くなってしまったこともあり、言語やソフトウェア固有の話は記事を分けることにしました。

いまのところ元記事から分割した Java 編のみにリンクを張っていますが、他の言語やソフトウェア特有の話をまとめた記事があったら、そちらも紹介させていただくかもしれません。 [^other-languages-software]

* [タイムゾーン呪いの書 (Java 編)](./curse-of-timezones-java-ja)

[^other-languages-software]: 本記事の筆者も、もう少しがんばったら (Ruby on Rails を除く) Ruby の話と Linux あたりの話は書けるかもしれません。しかし Ruby on Rails の話は厳しそうですし、言語以外でも MySQL あたりの話は厳しい…、と思っておりまして、どなたかぜひ。

内部データ表現
---------------

最初に検討するのは、時刻の内部データ表現をどうするか、すなわちソフトウェアの中で時刻データをどういう形式で保持するか、です。まずはどんな場合でも成り立つ大原則を考え、次に以下の三点をもとに個別の検討を始めるといいでしょう。

* うるう秒をあつかう必要があるか?
* 暦の計算、タイムゾーンの切り替わりをまたぐ計算をするか?
* 確定した過去の時刻か? 未来の予定の時刻か?

以下、細かく検討していきましょう。

### どんな場合でも成り立つ大原則

まず、タイムゾーンが不明なままの「年・月・日・時・分・秒」 [^java-local-date-time] を、そのまま保持し続けない、そのまま持ち回らない、というのを大原則にしましょう。

[^java-local-date-time]: Java JSR 310 で言えば [`java.time.LocalDateTime`](https://docs.oracle.com/javase/jp/8/docs/api/java/time/LocalDateTime.html) など。

RDB やユーザー入力など外部からのデータには、タイムゾーンが不明だったり曖昧だったりする「年・月・日・時・分・秒」が入っていることはよくあります。気をつけるのは、プログラム中でその日時をそのまま保持し続けない、そのまま持ち回らないことです。できるだけ早く、その日時がどのタイムゾーンのものかを確定し、日時とタイムゾーンをセットで保持するようにしましょう。

多くのソフトウェアは、複数の人がメンテナンスするものです。曖昧な情報をそのまま保持していると、認識の齟齬から、容易にバグが入り込むことになります。特に、公開メソッドの返り値などとしてタイムゾーン不明な日時を返すのは危険信号です。

オフセットまで確定して Unix time に、または「Unix time に変換可能」な形式にできれば、タイムゾーンの呪いをかなり軽減できるでしょう。しかし後述するように、「Unix time に変換可能」な形式にすることが常にベストとはかぎりません。以下、さまざまな要件に対してどうするのがいいのか、検討していきましょう。

### うるう秒をあつかう必要があるか?

まず考えるのはうるう秒です。銀行や金融などの業務では、うるう秒を厳密にあつかう必要があるかもしれません。この場合、前述した Unix time の定義から、内部表現として Unix time を使う選択肢が消滅します。しかしそれはあまりにも茨の道です。実装の複雑さも、かかる時間も、バグの入り込みやすさも、大幅に上がるでしょう。 [^implementing-leap-second]

[^implementing-leap-second]: そもそもうるう秒をしっかりあつかえるライブラリが多くありません。たとえば JSR 310 も、単体でうるう秒をあつかうのには不十分です。どうしてもうるう秒をあつかわなければならない場合、それでも自分で実装するよりはマシなので、できるだけいいライブラリを見つけてきてライブラリにまかせましょう。 Java の場合は JSR 310 と [ThreeTen-Extra](https://www.threeten.org/threeten-extra/) というライブラリの組み合わせで、うるう秒もある程度カバーできます。 ThreeTen-Extra はもともと JSR 310 の一部として検討されていたクラス群ですが、その JSR 310 があまりに肥大化したために整理され、外部ライブラリとして切り出されたものです。

うるう秒がビジネスを左右するほど重要な要件でないかぎり、うるう秒を考慮した仕様にするのはできるだけ避けることをおすすめします。たとえば一般消費者向けの Web サービスで、厳密なうるう秒が必要なケースはほぼないと思います。うるう秒は、まずうまくごまかせないか検討しましょう。

一秒の長さが厳密でなくともよければ、前述の Java タイム・スケール (UTC-SLS) やクラウドサービスの Leap Smear がそのまま使えるかもしれません。ほとんどの場合はそうだと思いますし、これが一番簡単です。または、秒未満の時間を考える必要がなければ、うるう秒の秒未満の逆進を考慮しなくてもいいので、「59分 59秒」に 2秒かける選択肢もあるかもしれません。もしそこで必要なのが経過時間であって時刻ではないのなら、そもそも多くの言語ではそのための API が時刻関連とは別にあります。 [^java-nano-time]

[^java-nano-time]: Java なら [System.nanoTime()](https://docs.oracle.com/javase/jp/8/docs/api/java/lang/System.html#nanoTime--)など。

うるう秒さえごまかせるなら、内部表現の第一選択肢は Unix time になるでしょう。うるう秒を除けば解釈にあいまいさがなく、使うメモリも少なく、秒単位の単純な計算は非常に簡単に行えます。たとえばイベント発生時刻の記録などには十分です。一つ注意点としては、単純な数値型そのままで Unix time を保持していると、時差の計算が混ざってきたときに混乱してバグを生みがちです。 Unix time 専用のクラスや型があれば、そちらを使っておくといいでしょう。 [^java-instant]

[^java-instant]: Java JSR 310 の [`java.time.Instant`](https://docs.oracle.com/javase/jp/8/docs/api/java/time/Instant.html) など。

ただし Unix time も万能ではありません。後述していくように、うるう秒をごまかせても Unix time が適さないケースもあります。

### 暦の計算、タイムゾーンの切り替わりをまたぐ計算をするか?

「翌日」や「同月の最終営業日」のような、暦の計算が必要なことがあります。そんなときはタイムゾーンの呪いがセットでやってきます。夏時間などの、タイムゾーンの切り替わりをまたぐ可能性があるからです。

まずは、たとえば要件が「翌日」なら、それが「24時間後 (うるう秒を無視できれば 86400秒後)」でいいのか、それとも「次の日の同じ時刻」である必要があるのか、要件を明らかにすることです。そしてうるう秒のあつかいと同様、できれば前者で済ませられないか検討しましょう。前者であれば Unix time で秒の計算をするだけでいいし、「次の日の同じ時刻」が存在しなかったり二重に存在したりするような事態も考えなくてよくなります。

「次の日の同じ時刻」までの時間は、夏時間を考慮すると 23時間かも 24時間かも 25時間かもしれません。日本で 2018年に検討された夏時間の例では 22時間かも 26時間かもしれません。 [^batch] サモアのような例を考慮すると、「次の日」自体がまったく存在しないことすらあります。

[^batch]: 時刻がバッチ処理にかかわっていると、「次の日の同じ時刻」までの時間が短くなる場合、いわゆる「バッチの突き抜け」が起こりやすくなる、という問題もありますね。

それでも「次の日の同じ時刻」が必要な場合、少なくともタイムゾーンを考慮した計算を自分で実装しようとするのはやめましょう。その場合、まずは日付・時・分・秒と地理ベースのタイムゾーンを組み合わせた形で時刻を保持し、計算はライブラリにまかせるのが最低ラインです。 [^java-zoned-date-time]

[^java-zoned-date-time]: Java JSR 310 の [`java.time.ZonedDateTime`](https://docs.oracle.com/javase/jp/8/docs/api/java/time/ZonedDateTime.html) など。

しかし、ライブラリにまかせておけばなんでもやってくれるわけではありません。「次の日の同じ時刻」が存在しなかったり二重に存在したりするような事態に際してどうするのかは、そもそも要件と仕様にかかわります。自分たちで詰めないとどうしようもありません。エラーにする、無視してさらに次の日にする、できるだけ切り替わり前のオフセットに寄せる、できるだけ切り替わり後のオフセットに寄せる、できるだけ「標準時」に寄せる [^lean-to-standard-time] などいろいろな選択肢があり、どれも一長一短です。要件とにらめっこして考えましょう。

[^lean-to-standard-time]: たとえば、できるだけ「標準時」に寄せても、サモアや EU の夏時間廃止の例のように「標準時」自体が変わることもありますね。

「日付・時・分・秒と地理ベースのタイムゾーンを組み合わせた形で時刻を保持」と書きましたが、地理ベースのタイムゾーンだけではなく `-07:00` のようなオフセットも同時に保持することも検討しましょう。 [^java-zoned-date-time-with-offset] たとえばカリフォルニア州が夏時間から標準時に戻る日の `2020-11-01 01:00:01 America/Los_Angeles` は、オフセットがないので夏時間 (`-07:00`) なのか標準時 (`-08:00`) なのかわかりません。

[^java-zoned-date-time-with-offset]: Java JSR 310 の [`java.time.ZonedDateTime`](https://docs.oracle.com/javase/jp/8/docs/api/java/time/ZonedDateTime.html) は、オプションとしてオフセットも保持できます。

時刻データを、常に「Unix time に変換可能」な形式で、言い換えると「その時刻が世界共通の時間軸のどこにあたるのかがわかる」形式で保持しておくと、タイムゾーンの呪いをかなり軽減できます。

### 確定した過去の時刻か? 未来に予定された時刻か?

時刻をデータとしてあつかうとき、おもに二種類の目的があると思います。過去に起きた事象の記録としての時刻と、未来に起こる予定の時刻です。この二つで、あつかいかたは大きく変わります。未来に起こる予定には、たとえば東京オリンピック開会式の開始予定日時のようなものもあるかもしれませんし、「毎週火曜日の正午」のような繰り返しの予定もあるかもしれません。店舗の営業時間や `cron` なども含まれます。

過去に起きたこととその時刻は、事実として確定しています。 [^steins-gate] 確定したその時刻は世界共通の時間軸上の一点に対応するので、つまり Unix time で表現できるでしょう。

[^steins-gate]: 相対論とか[シュタインズ・ゲートの選択](https://ja.wikipedia.org/wiki/STEINS;GATE)とかは忘れましょう。

補足情報として、その事象が起きたタイムゾーン (地域) は保持しておいてもいいかもしれません。特に人が関係した事象をあとから人が確認するとき、その時刻を、今いるタイムゾーンの時刻でではなく、事象が起きた場所の現地時刻で確認したいことは多いでしょう。地域 (タイムゾーン) ではなくオフセットで保持する選択肢もありますが、「過去の」 Unix time と地域ベースのタイムゾーンがあれば、その当時のオフセットを確定することもできます。ただし、ひとたび年・月・日・時・分・秒の形式でログなどに出力してしまうと、年・月・日・時・分・秒と地域ベースのタイムゾーンだけからは時刻を確定できないことに注意してください。

ひるがえって、未来に起こる予定の時刻をあつかうときは、その時刻の意味を慎重に考える必要があります。その時刻は、その事象が起こる絶対時刻を現地時刻で表現しただけでしょうか。それとも、予定されている事象 (イベントなど) の時刻自体が現地時刻で決まっているのでしょうか。

たとえば、次に[日本から観測できる皆既日食・金環日食は、日本時間の 2030年 6月 1日](https://www.nao.ac.jp/astro/sky/2020/06-topics03.html)で、札幌から中心食を観測できるのはその日の日本時間 16時 54分から 16時 58分までだそうです。もちろん太陽も月も日本という国の時刻制度のことなど知ったことではないので、仮にこのときまでに日本に夏時間が導入されても絶対時刻は変わりません。そのときは日本時間での表現のほうを直すことになります。

しかし別の例として、[延期前の東京 2020 オリンピック開会式の開始予定時刻は 2020年 7月 24日 20時](https://sports.nhk.or.jp/olympic/schedules/sports/ceremony.html)だったそうです。 [^tokyo-olympics-2020] この開始時刻は現地時刻 (日本時間) で決まっていたと思われます。つまり、仮にこの開始時刻が決まったあとで夏時間の導入が決定していたら、日本時間での開始時刻は変わらず、絶対時刻のほうが変わるのです。 [^tokyo-olympics-2020-if] このような未来の時刻を、その時点の tzdb をもって Unix time に変換して保持してはいけないのです。

[^tokyo-olympics-2020]: [「開会式・閉会式は午後8時から　東京五輪、日程決定」 (2019年 4月 16日、日本経済新聞)](https://www.nikkei.com/article/DGXMZO43777070W9A410C1000000/)

[^tokyo-olympics-2020-if]: もっとも、実際にはこの開始時刻が決まったのは夏時間の導入を断念したあとでしたし、仮にそうなっていたとしてもスポンサーや各国放送局の都合などの理由で時間をずらしたのでしょうが…。

これはたとえば各国証券取引所の取引時間なども同様で、基本的には現地時間です。 2021年時点で[ニューヨーク証券取引所の取引時間はニューヨーク時間 (東部時間) の 9時 30分から 16時](https://www.nyse.com/markets/hours-calendars)で、標準時の期間でも夏時間の期間でも現地時間の 9時 30分から 16時です。仮に将来ニューヨーク州が夏時間制を廃止しても、おそらく取引時間は夏時間廃止後の現地時間の 9時 30分から 16時になるのでしょう。

こんなときは Unix time ではなく、時・分・秒ベースの時刻表現とタイムゾーンと保持する必要があります。ここでは地域ベースのタイムゾーンが必要になります。タイムゾーン情報をオフセットに変換すると Unix time に変換したときと同様になってしまうからです。

そして、地域ベースのタイムゾーンをあつかうときは、前述の各種問題を頭に入れておくことを思い出しましょう。極端な場合は、タイムゾーンのオフセットがサモアのように想定外に変わって、もともと決まっていた日付や時刻がなくなってしまうかもしれません。

まあそんなときは、ソフトウェアだけではなく、そのイベントをつかさどる人間も困っています。それぞれのイベントが、それぞれなにかしら特別な対応をするでしょう。ソフトウェアとしては、仮にそんなことが起こっても変な挙動だけはせず、問題を検出してあとから考えられるような構造にしておく、くらいしかできることはないかもしれませんね。

データの出力と永続化
---------------------

時刻データの出力や永続化、他のコンポーネントへの受け渡しでも、考えることの基本は内部データ構造と同様です。

ただし、永続化したデータや受け渡したデータには「自分以外の読み手」がいることが常に想定されます。意図しない使われ方を防ぐために、以下のことに気をつけると、より良いでしょう。

* Unix time で済む場合はできるだけ Unix time を使う。
  * Unix time 専用のクラスや型がある場合はそれを使う。
  * 後述のように文字列表現にするときは、時刻だと明らかにするために Unix time (数値) ではなく年・月・日・時・分・秒 + 固定 `UTC` の形式にする案も合理的。
* タイムゾーン情報を省略しない。常に `UTC` と決めている場合も `UTC` を明示する。
  * Unix time 専用のクラスや型を使う場合は、既に明示されていると言える。
* 地域ベースのタイムゾーンに加えて、オフセットを確定するべき場合はオフセットも付ける。
  * 常に「Unix time に変換可能」な形式にする原則。

### 時刻の文字列表現

時刻データの出力先が RDB などであれば時刻用の型があることが多いですが、時刻を JSON などに入れなければならないこともあります。そのときは文字列などに落とさなければなりません。

文字列にするときは独自のフォーマットを作らず、共通のものを使っておくといいでしょう。一昔前はメールなどで使われる [RFC 2822](https://datatracker.ietf.org/doc/html/rfc2822) の形式 (`Fri, 27 Dec 2002 09:25:00 +0900` など) がよく使われていましたが、現在では [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) に沿った形式 (`20211231T123456+0900` や `2021-12-31T12:34:56+09:00`) のほうが主流です。 Java の JSR 310 も ISO 8601 を強く意識して作られています。

ただし ISO 8601 には地域ベースのタイムゾーンに関する仕様は含まれていません。 JSR 310 は `2021-12-31T12:34:56+09:00[Asia/Tokyo]` のように表記を拡張していますが、標準があるわけではないようです。

くどいですが、地域ベースのタイムゾーンを出力するとき `JST` などのあいまいな略称は使わないようにしましょう。

データの入力
-------------

### 現在時刻の取得

そのソフトウェアが今動いているコンピュータの現在時刻だけなら、ほとんどの場合は言語の標準 API などを使って取得できるでしょう。

しかし現代のソフトウェアの多くは、そんなに単純ではありません。サーバ・アプリケーションならブラウザなどのクライアントの時刻とタイムゾーンを、クライアント・アプリケーションならサーバの時刻とタイムゾーンを、気にしなければならないことがままあります。

特に通信が関係する場合は、それらをごちゃごちゃにしないように、時刻データにすぐにタイムゾーン情報を組み合わせる大原則を思い出しましょう。

### 永続化されたデータや外部データソースからの入力

前段のように自分で永続化したデータは設計したとおりに読み込めるはずですが、読み込むのは理想的なデータばかりではありません。 RDB から年・月・日がバラバラのカラムに入ったテーブルを読まなければならないかもしれませんし、タイムゾーンの明らかでない `DATETIME` 型のカラムを読まなければならないかもしれません。いずれの場合も、原則にしたがってできるだけ早く、その日時が正しいものであるか確認し、どのタイムゾーンのものか確定してから持ち回りましょう。

読み込む時刻が文字列の場合、前述の ISO 8601 に従っていれば簡単ですが、そうでないこともあります。ありがちな問題としては、アメリカ合衆国の慣習にならって年・月・日を「月・日・年」で並べた文字列がやってくるかもしれません。そのデータソースの仕様や規約を確認して読み込み、正しい日時であるか確認し、明示的にタイムゾーンと合わせて持ち回りましょう。

`CST` のようなあいまいなタイムゾーン略称が入った文字列がやってきてしまうこともあります。その場合、やはりまずはデータソースの仕様や規約を確認しましょう。「`CST` は `UTC-06:00` のこと」や「`CST` は `UTC+08:00` のこと」など決めてくれているかもしれません。不幸にもそこが未定義の場合、各略称がそれぞれどのタイムゾーンに当たるのか、対応関係を自分たちでメンテナンスする覚悟を決めましょう。 [^java-datetimeformatter]

[^java-datetimeformatter]: ちなみに [Java JSR 310 の `java.time.format.DateTimeFormatterBuilder#appendZoneText`](https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/DateTimeFormatterBuilder.html#appendZoneText-java.time.format.TextStyle-) は、あいまいなタイムゾーン略称を受け取ると locale などから判断してタイムゾーンを選んでくれるそうです。…しかしこの仕様、本当に嬉しいですかね? 環境依存バグを埋め込むフラグにしか見えませんが。

### ユーザーからの入力

ユーザーが時刻を入力する場合、その時刻が、どの地域 (タイムゾーン) のどのオフセットのものかが問題です。

まずは想定されるユーザーの意図を、要件から検討しなければなりません。とくに未来の時刻を入力する場合、前述の例のように「将来も確定している絶対時刻」を入力したいのか、「標準時の規定によって将来ずれるかもしれない現地時刻」を入力したいのか、目的と要件によって異なるでしょう。

ユーザーが想定するタイムゾーンを確定・推定する方法はいくつか考えられます。大きく分けると、時刻と一緒に手で入力してもらう、ユーザー・アカウントなどに事前に設定しておいてもらう、ユーザーが「今いる」タイムゾーンを使う、の三通りくらいになるのではないでしょうか。

手で入力してもらうのは、煩雑ですが確実です。限定された「わかっている」ユーザーが対象の場合や、間違いが許されない重要な設定の場合は、これが有力な選択肢になります。また、おもな手段として手入力以外を採用した場合でも、最後の手段として手で編集する余地を残す、という設計もあるでしょう。

たとえば [Amazon RDS のメンテナンスウィンドウ設定](https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow)は、時刻を手入力させるようになっています。今は `UTC` 固定での入力になっていますが、昔はタイムゾーンも手で指定可能でした。これは「限定された『わかっている』ユーザーが対象」で、かつ「間違いが許されない重要な設定」なので、妥当な設計に見えますね。タイムゾーンを指定可能と言っても、地域ベースのタイムゾーン (`America/Los_Angeles` など) は選択肢になく、オフセット (`-07:00` など) のみだったのですが、ここまで読んでいただいた方なら理由はわかると思います。

ユーザー・アカウントなどに設定しておいてもらう方法は、もちろんアカウントなし一回利用 (one-time) のシステムでは使えません。そのうえ、ユーザーが旅行などで他のタイムゾーンに移動したときに、ユーザーが設定の追従を忘れる可能性も考慮に入れなくてはならないでしょう。いちいち手で入力させないまでも「今あなたが入力しようとしているのは東京時間です」とわかる表示だけでもあれば、間違いを減らせるかもしれません。

このようなユーザー・アカウントへの設定は、地域ベースのタイムゾーンにすることが多いでしょう。すると、いつものタイムゾーンの呪いがやってきます。 `America/Los_Angeles` に設定されたユーザーが 2020年 3月 8日 午前 1時 30分と入力したら、どうすればいいでしょうか。これも要件に応じて対処を考える必要があります。

Google Calendar は、設定済みのタイムゾーン (地域) の外からブラウザでアクセスすると、ユーザーが「今いる」タイムゾーンを検出して「メインのタイムゾーンを○○に更新しますか?」と聞いてくれます。勝手に変更するわけではなく確認が入るのは、間違いを防ぐためにも有効そうですね。

しかし、ユーザーが「今いる」タイムゾーンを使うのは意外と厄介です。

まず、「ユーザーが今いる場所」と「ユーザーが入力したいタイムゾーン」が一致しているかは、自明ではありません。旅行から帰ったあとの予定を旅行先から入れたい場合、異なるタイムゾーンにいる上司との定期ミーティングを設定したい場合、違う国にあるサーバのメンテナンス時間を設定したい場合など、いろいろなケースがあります。

そして、「今いる」タイムゾーンを取得する方法も確実ではありません。スマートフォンは通信回線と現在位置からタイムゾーンを推定するので、スマートフォンのアプリなどで取得できる情報はそこそこ信頼できます。しかし、頻繁に旅行や出張をする人の中には、ノートパソコンのタイムゾーンを常に現在地に合わせているわけではない人もけっこういます。

しばらく前まで、ブラウザから安定して取得できるタイムゾーン情報はオフセットのみでした。ブラウザから tzdb 形式のタイムゾーン ID を取得する API ([`Intl.DateTimeFormat().resolvedOptions().timeZone`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)) がほとんどのブラウザでサポートされるようになったのは、かなり最近のことです。しかしこれも、結局はそのスマートフォンや (ノート) パソコンのタイムゾーン設定です。

基本的には、ユーザーが「今いる」タイムゾーンを確実な情報源だと考えてはいけません。ヒント程度に捉えておきましょう。時刻をブラウザに表示するときや、入力時のデフォルトに用いるくらいならよさそうですが、入力するデータ、特に永続化するデータの根拠として用いるのは危険だと考えたほうがいいでしょう。

Time Zone Databaseの更新
-------------------------

tzdb は新しい版が頻繁にリリースされます。古い版の tzdb を使っていると、地域によって時刻の解釈がおかしくなってしまい、それが致命的な問題を引き起こすこともあるでしょう。

ネイティブアプリケーションやライブラリの開発は tzdb のバージョン管理とは独立ですが、オンラインサービスの運用はそうもいきません。サモアのように大きな変更が直前に入ることがあると考えると、コーディング以外に tzdb 更新の戦略もしっかり立てておかなければなりません。いま作っているソフトウェアがどこの tzdb を参照していて、なにを更新すれば tzdb が更新されるのかを把握しておきましょう。

Javaで使われるtzdbはJava Runtimeの各バージョンに付属します。

言語に依らない戦略
-------------------

JSR 310 の場合の一般化になりますが、以下の点に気をつけるといいだろうと筆者は考えています。

* うるう秒を気にしなくてよく、昔の日付時刻を扱う必要もなければ、内部表現を UNIX 時間で持ち回れないか検討する。
* 日付時刻データを、特に外部コンポーネントとのインターフェースに使う場合や、外部に保存する場合 :
    * 特別に省略する必要性がない限り、タイムゾーン情報は省略しない。
    * タイムゾーン情報が必要ない場合は明示的に UTC に変換して、データにも明示的に UTC と持たせる。
    * タイムゾーンが必要でも固定オフセット (`"+09:00"` など) で済む用途なら、なるべく固定オフセットを使う。
    * 地域ベースのタイムゾーンが必要な場合は、オフセットの追記ができないか検討する。
* コード内で日付時刻データを扱う場合 :
    * タイムゾーン無しの日付時刻や地域ベースのタイムゾーンを扱う範囲を、コードの一部に限定できないか検討する。
* 地域ベースタイムゾーンを使う場合は、実行環境 (OS, ランタイム) やライブラリの仕様を調べて tz database の更新戦略を立てる。
* 3文字/4文字のタイムゾーン略語は使わず、地域ベースのタイムゾーンが必要な場合は、できるだけ tz database 名を使う。略語を使わざるをえない場合は、どの略語がどのタイムゾーンに対応するか、仕様から明示する。
